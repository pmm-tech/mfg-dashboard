# This simplified pipeline leverages a runner with Docker socket binding.
stages:
  - build_and_push_cms
  - build_and_push_nginx

workflow:
  rules:
    - if: '$CI_COMMIT_TAG'

variables:
  # Update with your registry path (e.g., your Docker Hub username/repo)
  IMAGE_REGISTRY_PATH: ${CI_REGISTRY_IMAGE}
  IMAGE_REGISTRY_PATH_NGINX: ${CI_REGISTRY_IMAGE_NGINX}
  DOCKERFILE_PATH: "build/Dockerfile"
  DOCKERFILE_PATH_NGINX: "build/Dockerfile.nginx"

build_and_push_cms:
  stage: build_and_push_cms
  tags:
    - brightschools
  # Use an image that has the Docker client and Git.
  image: docker:24.0.5-git
  script:
    # 1. Determine the image tag based on the trigger (Git tag or branch commit)
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        # For a git tag like 'v1.2.3', use '1.2.3' as the docker tag.
        VERSION=$(echo $CI_COMMIT_TAG | sed 's/^v//')
        export IMAGE_TAG="${IMAGE_REGISTRY_PATH}:${VERSION}"
        echo "Building release image for Git tag: $IMAGE_TAG"
      else
        # For branch commits, use the short commit SHA for traceability.
        export IMAGE_TAG="${IMAGE_REGISTRY_PATH}:${CI_COMMIT_SHORT_SHA}"
        echo "Building development image for branch '$CI_COMMIT_BRANCH': $IMAGE_TAG"
      fi

    # 2. Log in to your Docker registry
    # Ensure CI_DOCKER_USER and CI_DOCKER_TOKEN variables are set in GitLab settings.
    - echo "$CI_DOCKER_TOKEN" | docker login -u "$CI_REGISTRY_USER" --password-stdin

    # 3. Build the image
    - docker build -f ${DOCKERFILE_PATH} -t ${IMAGE_TAG} .

    # 4. Push the image
    - echo "Pushing image $IMAGE_TAG"
    - docker push ${IMAGE_TAG}

    # 5. For official releases, also push a 'latest' tag
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        LATEST_TAG="${IMAGE_REGISTRY_PATH}:latest"
        echo "Tagging and pushing latest tag: $LATEST_TAG"
        docker tag $IMAGE_TAG $LATEST_TAG
        docker push $LATEST_TAG
      fi

build_and_push_nginx:
  stage: build_and_push_nginx
  tags:
    - brightschools
  image: docker:24.0.5-git
  script:
    # 1. Determine the image tag based on the trigger (Git tag or branch commit)
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        # For a git tag like 'v1.2.3', use '1.2.3' as the docker tag.
        VERSION=$(echo $CI_COMMIT_TAG | sed 's/^v//')
        export IMAGE_TAG="${IMAGE_REGISTRY_PATH_NGINX}:${VERSION}"
        echo "Building release image for Git tag: $IMAGE_TAG"
      else
        # For branch commits, use the short commit SHA for traceability.
        export IMAGE_TAG="${IMAGE_REGISTRY_PATH_NGINX}:${CI_COMMIT_SHORT_SHA}"
        echo "Building development image for branch '$CI_COMMIT_BRANCH': $IMAGE_TAG"
      fi

    # 2. Log in to your Docker registry
    # Ensure CI_DOCKER_USER and CI_DOCKER_TOKEN variables are set in GitLab settings.
    - echo "$CI_DOCKER_TOKEN" | docker login -u "$CI_REGISTRY_USER" --password-stdin

    # 3. Build the image
    - docker build -f ${DOCKERFILE_PATH_NGINX} -t ${IMAGE_TAG} .

    # 4. Push the image
    - echo "Pushing image $IMAGE_TAG"
    - docker push ${IMAGE_TAG}

    # 5. For official releases, also push a 'latest' tag
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        LATEST_TAG="${IMAGE_REGISTRY_PATH_NGINX}:latest"
        echo "Tagging and pushing latest tag: $LATEST_TAG"
        docker tag $IMAGE_TAG $LATEST_TAG
        docker push $LATEST_TAG
      fi